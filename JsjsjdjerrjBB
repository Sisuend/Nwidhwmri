repeat task.wait() until game:IsLoaded()

local GC = getconnections or get_signal_cons
for i, v in next, GC(game:GetService("Players").LocalPlayer.Idled) do
    v:Disable()
end

-- // Main Variables // --
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local Player, ReplicatedStorage, Debris = Players.LocalPlayer, game.ReplicatedStorage, game.Debris
local char = Player.Character or Player.CharacterAdded:Wait()
local CanHit = false
local Camera = Workspace:FindFirstChild("Camera")
local Alive = Workspace:FindFirstChild("Alive")
local Dead = Workspace:FindFirstChild("Dead")
local Balls = Workspace:WaitForChild("Balls", 9e9)

local PlayerScripts = Player.PlayerScripts
local EffectScripts = PlayerScripts.EffectScripts
local ClientFX = EffectScripts.ClientFX
local Shake = ClientFX.Shake
local ParryCD=false;
local win = Player.leaderstats.Wins.Value
local kill = Player.leaderstats.Elims.Value
local Remotes = {
    ThunderDash = ReplicatedStorage.Remotes.ThunderDash, 
    Emote = ReplicatedStorage.Remotes.CustomEmote,
    Parry = ReplicatedStorage.Remotes.ParryButtonPress
}

-- || Main Stuff || --
local function Char()
    return Player.Character
end

function IsTarget()
    return (Char() and Char():FindFirstChild("Highlight"))
end

local function FindBall()

    local RealBall
    for i, v in pairs(Balls:GetChildren()) do
        if v:GetAttribute("realBall") == true then
            RealBall = v
            break -- Exit the loop once the real ball is found
        end
    end
    return RealBall
end

function GetPlayerC()
    local Max, Target, Players = math.huge, nil, game:GetService("Players")
    for i,v in next, Players:GetPlayers() do
        if v ~= Player and v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
            local Mag = (Player.Character:GetModelCFrame() - v.Character:GetModelCFrame()).Magnitude
            if Mag <= Max then
                Target = v
            end
        end
    end
    return Target
end

function GetBall()
    local RealBall

    for i, v in pairs(Balls:GetChildren()) do
        if v:GetAttribute("realBall") == true then
            RealBall = v
        end
    end
    return RealBall
end

local function getPlayerPing()
    local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
    return ping
end

local function MapPingToDistance()
    local ping = getPlayerPing()

    local pingThreshold = {
        [50] = 15,
        [100] = 20,
        [120] = 25
    }

    local ClosestDistance = 10

    for pingValue, distance in next, pingThreshold do
        if ping <= pingValue then
            ClosestDistance = distance
            break;
        end
    end

    return ClosestDistance
end


local function get_plr()
    return game.Players.LocalPlayer
end
  
local function get_plrChar()
    local plrChar = get_plr().Character
    if plrChar then
        return plrChar
    end
end

local function get_plrRP()
    local plrRP = get_plrChar():FindFirstChild("HumanoidRootPart")
    if plrRP then
        return plrRP
    end
end

local function get_PlayersNumber()
    local Alive = workspace:WaitForChild("Alive", 20):GetChildren()
    local PlayersNumber = 0
    for _,v in pairs(Alive) do
        if v and v:FindFirstChild("Humanoid") and v.Humanoid.Health > 50 then
            PlayersNumber = PlayersNumber + 1
        end
    end
    return PlayersNumber
end

local function get_ProxyPlayer()
    local Players = workspace:WaitForChild("Alive"):GetChildren()
    local Distance = math.huge
    local plr = game.Players.LocalPlayer
    local plrRP = plr.Character:FindFirstChild("HumanoidRootPart")
    local Player = nil

    for _,plr1 in pairs(Players) do
        if plr1.Name ~= plr.Name and plrRP and plr1:FindFirstChild("HumanoidRootPart") and plr1:FindFirstChild("Humanoid") and plr1.Humanoid.Health > 50 then
        local magnitude = (plr1.HumanoidRootPart.Position - plrRP.Position).Magnitude
            if magnitude <= Distance then
                Distance = magnitude
                Player = plr1
            end
        end
    end
    return Player
end


function calculateProjectileTime(initialPosition, targetPosition, initialVelocity)
	local distance = (targetPosition - initialPosition).Magnitude
	local time = distance / initialVelocity.Magnitude
	return time
end

function calculateDistance(projectilePosition, objectPosition)
	return math.abs((projectilePosition - objectPosition).Magnitude)
end

local function Parry(ball)
    Remotes.Parry:Fire()
    ball:SetAttribute('target',  "")
    ParryCD = true
    task.delay(.1, function()
        ParryCD = false
    end)

end


local function Click_Button()
    task.spawn(function()
        local ball = GetBall()
        if (ball) then
            local plr = game.Players.LocalPlayer
            local plrFind = workspace.Alive:FindFirstChild(plr.Name)
            if plrFind then
                local plrs = 0
                for _,v in pairs(workspace:WaitForChild("Alive", 10):GetChildren()) do
                    plrs = plrs + 1
                end
                if plrs > 1 then
                    Remotes.Parry:Fire()
                    --game.ReplicatedStorage.Remotes.ParryAttempt:FireServer(1.5, Workspace.CurrentCamera.CFrame, GetPlayerID(), {Workspace.CurrentCamera:WorldToScreenPoint(Player.Character.PrimaryPart.Position).X, Workspace.CurrentCamera:WorldToScreenPoint(Player.Character.PrimaryPart.Position).Y})
                    game:GetService("RunService").Heartbeat:Wait()
                end
            end           
        end

    end)
end

local function fullyPredictPosition(ball)
    if Char() and Char():FindFirstChild("HumanoidRootPart") then
        local rootPart = Char().HumanoidRootPart
        local relativePosition = ball.Position - rootPart.Position
        local velocity = ball.Velocity + rootPart.Velocity 

        local pingMultiplier = 1 + (getPlayerPing() / 100) -- Adjust this multiplier based on your preference

        -- Predict position based on current velocity
        local predictedPosition = ball.Position + velocity * calculatePredictionTime(ball) * pingMultiplier

        return predictedPosition
    end
    return math.huge -- Default position if something goes wrong
end


local function GetPlayerID()
    local ID = {}
    for i, v in pairs(Players:GetPlayers()) do
        local UserId, HumanoidRootPart = tostring(v.UserId), v.Character and v.Character:FindFirstChild("HumanoidRootPart")
		if HumanoidRootPart and v == Player then
            if v.Character:FindFirstChild("HumanoidRootPart") then
                ID[UserId] =  Workspace.CurrentCamera:WorldToScreenPoint(v.Character.PrimaryPart.Position)
            end
        end
    end
    return ID
end

local function calculatePredictionTime(ball)
    if Char() and Char():FindFirstChild("HumanoidRootPart") then
        local rootPart = Char().HumanoidRootPart
        local relativePosition = ball.Position - rootPart.Position
        local velocity = ball.Velocity + rootPart.Velocity 
        local a = (ball.Size.magnitude / 3) 
        local b = relativePosition.magnitude
        local c = math.sqrt(a * a + b * b)
        local timeToCollision = (c - a) / velocity.magnitude

        return timeToCollision
    end
    return math.huge
end

local function CreateUI()
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "BallTracker"
    ScreenGui.Parent = Player.PlayerGui

    local Frame = Instance.new("Frame")
    Frame.Size = UDim2.new(0, 150, 0, 90)
    Frame.Position = UDim2.new(0, 10, 0, 10)
    Frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    Frame.BackgroundTransparency = 0.5
    Frame.Parent = ScreenGui

    local DistanceLabel = Instance.new("TextLabel")
    DistanceLabel.Size = UDim2.new(1, 0, 0, 30)
    DistanceLabel.Position = UDim2.new(0, 0, 0, 0)
    DistanceLabel.BackgroundTransparency = 1
    DistanceLabel.Text = "Distance: N/A"
    DistanceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    DistanceLabel.Parent = Frame

    local VeloLabel = Instance.new("TextLabel")
    VeloLabel.Size = UDim2.new(1, 0, 0, 30)
    VeloLabel.Position = UDim2.new(0, 0, 0, 30)
    VeloLabel.BackgroundTransparency = 1
    VeloLabel.Text = "Velocity: N/A"
    VeloLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    VeloLabel.Parent = Frame

    -- Ping
    local PingLabel = Instance.new("TextLabel")
    PingLabel.Size = UDim2.new(1, 0, 0, 30)
    PingLabel.Position = UDim2.new(0, 0, 0, 60)
    PingLabel.BackgroundTransparency = 1
    PingLabel.Text = "Ping: N/A"
    PingLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    PingLabel.Parent = Frame

    game:GetService("RunService").RenderStepped:Connect(function()
        local Ball = FindBall()
        if Ball then
            local Distance = Player:DistanceFromCharacter(Ball.Position)
            DistanceLabel.Text = string.format("Distance: %.2f", Distance)
            local Velocity = Ball.AssemblyLinearVelocity.Magnitude / 3
            VeloLabel.Text = string.format("Velocity: %.2f", Velocity)
        else
            DistanceLabel.Text = "Distance: N/A"
            VeloLabel.Text = "Velocity: N/A"
        end

        local Ping = game:GetService("Stats"):FindFirstChild("Network") and game:GetService("Stats"):FindFirstChild("Network"):FindFirstChild("ServerStatsItem") and game:GetService("Stats"):FindFirstChild("Network"):FindFirstChild("ServerStatsItem"):FindFirstChild("Data Ping")
        if Ping then
            PingLabel.Text = string.format("Ping: %d", Ping:GetValue())
        else
            PingLabel.Text = "Ping: N/A"
        end
    end)
end

CreateUI()

Player.CharacterAdded:Connect(function()
    if Player.PlayerGui:FindFirstChild("BallTracker") then
        Player.PlayerGui.BallTracker:Destroy()
    end
    CreateUI()
end)
-- UI Creation
local UI = loadstring(game:HttpGet('https://raw.githubusercontent.com/JakeisSoBad/ganteng/main/MTHICHSKIDKO.lua'))()
local Window = UI:Create('GANTENG HUB', 'BLADE BALL', 'Premium User')
local Main = Window:CreateTab('Main', 'home')
local Log = Window:CreateTab('Log', 'home')
local Status = Window:CreateTab('Status', 'home')

-- Main Tab
Main:CreateLabel("Main")
Main:CreateToggle("Auto Parry", false, function(val)
    getgenv().AutoParry = val
end)


Main:CreateToggle("AI Auto Move", false, function(val)
    getgenv().ai = val
    local Players = game:GetService("Players")
    local Player = Players.LocalPlayer
    local targetPositions = {
        Vector3.new(-166, 10, -170),
        Vector3.new(-179, 8, 45),
        Vector3.new(-391, 6, 40),
        Vector3.new(-380, 8, -190)
    }
    local function getRandomTargetPosition()
        local randomIndex = math.random(1, #targetPositions)
        return targetPositions[randomIndex]
    end
    local function calculateMoveDirection(targetPosition)
        return (targetPosition - Player.Character.HumanoidRootPart.Position).Unit
    end
    local function move()
        local targetPosition = getRandomTargetPosition()
        local moveDirection = calculateMoveDirection(targetPosition)
        Player.Character.Humanoid:MoveTo(Player.Character.HumanoidRootPart.Position + moveDirection * 50) 
        wait(_G.Delay)
    end
    
    while getgenv().ai == true do
        move()
    end
    
end)
Main:CreateSlider("Delay AI",1,10,2,function(val)
    _G.Delay = val
end)

Status:CreateLabel("Player Name: " .. Player.Name)
Status:CreateLabel("Total Wins: " .. win)
Status:CreateLabel("Total Kills: " .. kill)

Window:CreateButton('earth', false, function(val)
    if val then
        Window:Notify('Time Change', 'Night', 1.5)
        game:GetService('TweenService'):Create(game:GetService('Lighting'), TweenInfo.new(0.5), { ClockTime = 0 }):Play()
    else
        Window:Notify('Time Change', 'Day', 1.5)
        game:GetService('TweenService'):Create(game:GetService('Lighting'), TweenInfo.new(0.5), { ClockTime = 14 }):Play()
    end
end)

Window:CreateButton('ads', false, function(val)
    if val then
        Window:Notify('FOV Change', '120', 1)
        game:GetService('TweenService'):Create(workspace.CurrentCamera, TweenInfo.new(0.5), { FieldOfView = 120 }):Play()
    else
        Window:Notify('FOV Change', '70', 1)
        game:GetService('TweenService'):Create(workspace.CurrentCamera, TweenInfo.new(0.5), { FieldOfView = 70 }):Play()
    end
end)


game:GetService("RunService").PreRender:Connect(function()
    if not getgenv().AutoParry then return end
    local playerCharacter = Player.Character
    local playerRootPart = playerCharacter and playerCharacter:FindFirstChild("HumanoidRootPart")
    
    if not playerRootPart then
        return
    end
    local Ball = FindBall()
    if not Ball then
        return
    end
    
    local Velocity = Ball.AssemblyLinearVelocity.Magnitude / 3
    local BallPosition = Ball.Position
    local Distance = Player:DistanceFromCharacter(BallPosition)

    if (IsTarget() and Ball["BrickColor"] == BrickColor.new("Bright red")) then
        task.spawn(function()
            Ball:SetAttribute("target", Player.Name)
        end)
    end
    if (Ball:GetAttribute('target') == (Player.Name or Player.DisplayName) or IsTarget()) and not ParryCD then
        if (Distance <= Velocity or Distance <= MapPingToDistance()) and calculatePredictionTime(Ball) < 1 then
            Parry(Ball)
        end
    end   
end)

task.spawn(function()
    while task.wait() do
        if getgenv().SpamClickA then
            Click_Button()
        end
    end
end)

--DetectSpam()
print('executed')
getgenv().DetectSpam = true
local SpamNum = 0
while getgenv().DetectSpam do 
    task.wait()
    local plrRP = get_plrRP()
    local ProxyPlayer = get_ProxyPlayer()

    local ball = GetBall()
    if not ball then
        getgenv().SpamClickA = false
    end
    
    if ball then
        local Velocity = ball.AssemblyLinearVelocity.Magnitude / 3
        local BallPosition = ball.Position
        local Distance = Player:DistanceFromCharacter(BallPosition)
        if (Distance <= Velocity or Distance <= MapPingToDistance()) then
            SpamNum = SpamNum + 1
        else
            SpamNum = 0
        end

        local args = ProxyPlayer and ProxyPlayer:FindFirstChild("HumanoidRootPart")
        local HL1 = ProxyPlayer and ProxyPlayer:FindFirstChild("Highlight")
        local HL2 = get_plrChar() and get_plrChar():FindFirstChild("Highlight")
        if plrRP and ((HL1 and args) or (HL2 and args)) then
            local DistancePlayer = (ProxyPlayer.HumanoidRootPart.Position - plrRP.Position).Magnitude
            local DistanceBall = (ball.Position - plrRP.Position).Magnitude
            if get_PlayersNumber() < 3 then
                if DistancePlayer <= 30 and DistanceBall <= 35 and SpamNum >= 2 then
                    getgenv().SpamClickA = true
                else
                    getgenv().SpamClickA = false
                end
            else
                if DistancePlayer <= 30 and DistanceBall <= 35 and SpamNum >= 3 then
                    getgenv().SpamClickA = true
                else
                    getgenv().SpamClickA = false
                end
            end
        else
            getgenv().SpamClickA = false
        end

    end
end

local lastHighlightState = false
local lastWinState = win

while wait(.00000000000000000000000000000001) do
    local currentHighlightState = Player.Character:FindFirstChild("Highlight") ~= nil
    local currentWinState = win

    if currentHighlightState ~= lastHighlightState then
        if currentHighlightState then
            Log:CreateLabel("In Target")
        else
            Log:CreateLabel("Not In Target")
        end
        lastHighlightState = currentHighlightState
    end

    if currentWinState ~= lastWinState then
        Log:CreateLabel("New Win")
        lastWinState = currentWinState
    end
end
